# RFC 7521：Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants 和訳

<!-- TOC -->

- [Document](#document)
- [Contents](#contents)
    - [Abstract](#abstract)
    - [1. Introduction](#1.-introduction)
    - [3. Framework](#3.-framework)
    - [4. Transporting Assertions](#4.-transporting-assertions)
        - [4.1. Using Assertions as Authorization Grants](#4.1.-using-assertions-as-authorization-grants)
        - [4.2. Using Assertions for Client Authentication](#4.2.-using-assertions-for-client-authentication)
    - [5. Assertion Content and Processing](#5.-assertion-content-and-processing)
        - [5.1. Assertion Metamodel](#5.1.-assertion-metamodel)
        - [5.2. General Assertion Format and Processing Rules](#5.2.-general-assertion-format-and-processing-rules)
    - [6. Common Scenarios](#6.-common-scenarios)
        - [6.1. Client Authentication](#6.1.-client-authentication)
        - [6.2. Client Acting on Behalf of Itself](#6.2.-client-acting-on-behalf-of-itself)
        - [6.3. Client Acting on Behalf of a User](#6.3.-client-acting-on-behalf-of-a-user)
    - [7. Interoperability Considerations](#7.-interoperability-considerations)
    - [8. Security Considerations](#8.-security-considerations)
        - [8.1. Forged Assertion](#8.1.-forged-assertion)
        - [8.2. Stolen Assertion](#8.2.-stolen-assertion)
        - [8.3. Unauthorized Disclosure of Personal Information](#8.3.-unauthorized-disclosure-of-personal-information)
        - [8.4. Privacy Considerations](#8.4.-privacy-considerations)

<!-- /TOC -->
## Document

[RFC 7521：Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants](https://tools.ietf.org/html/rfc7521)

## Contents

以下、関係ありそうな箇所のみ直訳。

### Abstract

  この仕様は、新しいクライアント認証メカニズムと新しい認可付与タイプの形でOAuth 2.0でアサーションを使用するためのフレームワークを提供します。 メカニズムは、トークンエンドポイントとのやり取り中にアサーションを転送するために指定されています。 一般的な処理ルールも指定されています。

  この仕様の目的は、OAuth 2.0がアサーションを使用して他のアイデンティティシステムと相互作用し、代替のクライアント認証メカニズムを提供するための共通のフレームワークを提供することです。

  この仕様は抽象的なメッセージフローと処理ルールを定義するだけであることに注意してください。 実装可能にするためには、対応する具体的なインスタンス化を提供するためにコンパニオン仕様が必要です。

### 1. Introduction

  [RFC](https://tools.ietf.org/html/rfc7521#section-1)

  アサーションは、セキュリティドメイン間でアイデンティティとセキュリティ情報の共有を容易にする情報のパッケージです。セクション3は、本明細書の目的のためのアサーションの概念のより詳細な説明を提供する。

  OAuth 2.0 [RFC6749]は、サードパーティのアプリケーションが保護されたHTTPリソースへの制限付きアクセスを得ることを可能にする認証フレームワークです。 OAuthでは、これらのサードパーティアプリケーションはクライアントと呼ばれます。アクセストークンをHTTPリソースに提示することによって保護されたリソースにアクセスします。アクセス・トークンは、リソース所有者の（時に暗黙の）承認を伴う許可サーバーによってクライアントに発行されます。これらのアクセストークンは、通常、リソース所有者（または特権管理者）によって付与された認可を表す認可許可を交換することによって取得されます。さまざまな種類のクライアントとユーザーエクスペリエンスをサポートするために、いくつかの認可許可タイプが定義されています。 OAuthは、OAuthと他のプロトコルフレームワークとの間の橋渡しとなる追加の許可タイプを定義するための拡張性メカニズムも提供します。

  この仕様は、OAuth 2.0でのアサーションの認可付与としての一般的なフレームワークを提供します。 また、クライアント認証に使用されるアサーションのフレームワークも提供します。 これは、許可サーバーのトークン・エンドポイントとの対話中にアサーションを転送するための一般的なメカニズムと、それらのアサーションのコンテンツおよび処理のための一般的なルールを提供します。 その目的は、代替クライアント認証メカニズム（クライアント秘密を送信しないもの）を提供し、エンドユーザが存在しないクライアント/サーバ統合シナリオでのOAuth 2.0の使用を容易にすることです。

  この仕様では、抽象的なメッセージフローと処理ルールのみを定義しています。 実装可能にするためには、対応する具体的なインスタンス化を提供するためにコンパニオン仕様が必要です。 たとえば、OAuth 2.0クライアント認証および認可グラントのセキュリティアサーションマークアップ言語（SAML）2.0プロファイル[RFC7522]では、セキュリティアサーションマークアップ言語（SAML）2.0アサーションと「JSON Webトークン（OWA）プロファイル 2.0クライアント認証と認可グラント "[RFC7523]は、JWTの具体的なインスタンス化を定義しています。

  注：クライアント認証のためのアサーションの使用は、アサーションを認可許可として使用することとは直交しています。 これらは組み合わせて使用することも、別々に使用することもできます。 クライアントアサーション認証は、クライアントがトークンエンドポイントに対して認証するための代替手段に過ぎず、完全で意味のあるプロトコル要求を形成するために、何らかの認可タイプとともに使用する必要があります。 アサーション認可付与は、クライアントの認証または識別の有無にかかわらず使用できます。 アサーション認可付与とクライアント認証がサポートされているかどうか、サポートされているクライアント認証のタイプは、認可サーバーの裁量によるポリシー決定です。

### 3. Framework

  [RFC](https://tools.ietf.org/html/rfc7521#section-3)

  アサーションは、IDとセキュリティ情報をセキュリティドメイン間で共有できる情報パッケージです。 アサーションには、通常、主体または主体に関する情報、アサーションを発行した当事者に関する情報、およびアサーションが発行された日時、およびアサーションが有効であるとみなされる条件（たとえば、いつどこで使用できるかなど）が含まれます。

  アサーションを作成し、署名し、完全性保護するエンティティは、通常、「発行者」と呼ばれ、アサーションを消費し、その情報に依存するエンティティは、通常、「依拠当事者」として知られています。 このドキュメントの文脈では、認可サーバーは依拠当事者として機能します。

  この仕様で定義されたプロトコル交換で使用されるアサーションは、イシュアを認証し、アサーション・コンテンツの完全性を保証する発行者によって適用されるデジタル署名またはメッセージ認証コード（MAC）を使用して常に完全性保護されなければならない。 多くの場合、アサーションは第三者によって発行され、それを提示するクライアントによる改ざんから保護する必要があります。 アサーションはさらに暗号化されて、権限のない当事者（クライアントなど）がコンテンツを検査するのを防ぐことができます。

  この文書では、クライアントがアサーションを取得するプロセス（認可サーバーに送信する前に）を定義していませんが、以下に説明する2つの共通のパターンがあります。

  図1に示す第1のパターンでは、クライアントは、セキュリティトークンを発行、更新、変換、検証することができる第三者エンティティからアサーションを取得します。 典型的には、そのようなエンティティは、「セキュリティトークンサービス」（STS）または単に「トークンサービス」として知られており、トークンサービスと依拠当事者との間に（通常は何らかの種類の鍵材料の交換で明示される）信頼関係が存在する 。 トークンサービスはアサーション発行者です。 その役割は、さまざまな資格情報を提示するクライアントからの要求を満たすこと、要求されるようにミントアサーションを行い、適切な情報を記入し、署名またはメッセージ認証コードでそれらを完全に保護することです。 WS-Trust [OASIS.WS-Trust]は、セキュリティトークン（アサーション）を要求するために利用できる標準の1つです。

```
     Relying
     Party                     Client                   Token Service
       |                          |                         |
       |                          |  1) Request Assertion   |
       |                          |------------------------>|
       |                          |                         |
       |                          |  2) Assertion           |
       |                          |<------------------------|
       |    3) Assertion          |                         |
       |<-------------------------|                         |
       |                          |                         |
       |    4) OK or Failure      |                         |
       |------------------------->|                         |
       |                          |                         |
       |                          |                         |

                Figure 1: Assertion Created by Third Party
```

  図2に示す第2のパターンでは、クライアントはアサーションをローカルに作成します。 アサーションに署名またはメッセージ認証コードを適用するには、対称キーまたは非対称キーペアのいずれかのキーマテリアルを取得する必要があります。 このキーマテリアルを取得するメカニズムは、この仕様の範囲を超えています。

  アサーションは、通常、アイデンティティとセキュリティ情報を伝達するために使用されますが、自己発行のアサーションは異なる目的にも役立ちます。 これらは、取引で実際に秘密を直接伝えることなく、クライアント秘密などの秘密の知識を実証するために使用できます。その場合、クライアント自身によるアサーションに含まれる追加情報は、Relying Partyにとっては限定的であり、この理由から、発行および使用条件に関する情報など、そのようなアサーションには最小限の情報しか含まれません 。

```
     Relying
     Party                     Client
       |                          |
       |                          | 1) Create
       |                          |    Assertion
       |                          |--------------+
       |                          |              |
       |                          | 2) Assertion |
       |                          |<-------------+
       |    3) Assertion          |
       |<-------------------------|
       |                          |
       |    4) OK or Failure      |
       |------------------------->|
       |                          |
       |                          |

                      Figure 2: Self-Issued Assertion

```

  デプロイメントは、必要なセキュリティレベル、エンティティ間の信頼関係、およびその他の要因に基づいて、使用する適切なバリアントを決定する必要があります。

  アサーションを提示するエンティティによって実行されなければならないことの観点から、アサーションには2つの一般的なタイプがあります。

  1. ベアラアサーション：ベアラアサーション（ベアラ）を所有しているすべてのエンティティは、関連するリソースへのアクセスを取得するためにベアラアサーションを使用できます（暗号鍵の所持を証明することなく）。誤用を防止するために、ベアラアサーションは、ストレージおよび輸送における開示から保護する必要があります。権限のない当事者にアサーションを漏らさないために、すべてのエンティティ間に安全な通信チャネルが必要です。

  2. ホルダーオブキーアサーション：アサーションを提示するエンティティは、関連するリソースにアクセスするために、追加の暗号資料の所持を証明しなければならない。したがって、トークンサービスは、アサーションにキー識別子をバインドし、クライアントは、アサーションを提示するときに、その識別子に対応するキーを知っていることを依拠当事者に示す必要があります。

  このドキュメントで定義されているプロトコルパラメータと処理ルールは、認可サーバへのベアラアサーションを提示するクライアントをサポートすることを目的としています。それらは、キーホルダーアサーションでの使用には直接適していません。鍵所有者アサーション・システムのベースラインとして使用することができますが、（秘密鍵の所有証明をサポートするための）追加のメカニズムが必要であり、場合によってはセキュリティ・モデルの変更（例：オーディエンスの要件を緩和するため）。

### 4. Transporting Assertions

  [RFC](https://tools.ietf.org/html/rfc7521#section-4)

  このセクションでは、OAuth認証サーバーのトークンエンドポイントとの対話中にアサーションを転送するためのHTTPパラメータを定義します。 トークンエンドポイントへのリクエストは、HTTPリクエストとレスポンスの両方でクリアテキスト認証情報を送信するため、トークンエンドポイントへのすべてのリクエストはOAuth 2.0のセクション3.2で規定されているTLS（Transport Layer Security）を使用しなければならない[RFC6749 ]。

#### 4.1. Using Assertions as Authorization Grants

  このセクションは、OAuth 2.0 [RFC6749]のセクション4.5で提供される定義に基づいて、認可付与としてのアサーションの使用を定義します。アサーションを認可付与として使用する場合、クライアントは次のHTTP要求パラメータを使用してアサーションおよび関連情報を含めます。

  - `grant_type`
    - 必須。許可サーバーによって定義されたアサーションの形式。値は絶対URIになります。

  - `assertion`
    - 必須。アサーションは認可付与として使用されます。アサーションの特定のシリアライゼーションは、プロファイル文書によって定義されます。

  - `scope`
    - オプション。要求された範囲は、OAuth 2.0 [RFC6749]の3.3節に記述されているとおりです。アクセストークンのアサーションを交換するとき、トークンの認可は、以前に一部のアウトオブバンドメカニズムによって許可されていました。したがって、要求されたスコープは、当初認可されたアクセッサに与えられたスコープと同じかそれよりも小さくなければならない（MUST）。認可サーバーは、発行されたアクセストークンのスコープを、認可されたアクセサーに最初に与えられたスコープ以下に制限する必要があります。

  OAuth 2.0 [RFC6749]のセクション3.2.1で説明されているように、クライアントの認証はオプションであるため、パラメータに依存するクライアント認証の形式が使用されている場合にのみ `client_id`が必要となります。

  次の例は、アサーションが認可付与として使用されていることを示しています（表示目的でのみ、改行が追加されています）。

```
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-bearer&
     assertion=PHNhbWxwOl...[omitted for brevity]...ZT4
```

  この文脈で使用されるアサーションは、一般的に認可付与の短命表現であり、認可サーバは、アサーションの有効期間をかなりの期間延長するアクセストークンを発行してはならない（SHOULD NOT）。 実際には、これは、通常、リフレッシュトークンがアサーション許可要求に応答して発行されず、アクセストークンが合理的に短い寿命で発行されることを意味します。 クライアントは、同じアサーションを使用して新しいアサーションを要求したり、それが有効である場合は新しいアサーションを使用して、期限切れのアクセストークンをリフレッシュできます。

  `grant_type`値として使用するIETF URNは、[RFC6755]のテンプレートを使って要求することができます。 `urn：ietf：params：oauth：grant-type：*`形式のURNが推奨されます。

##### 4.1.1.  Error Responses

  アサーションが有効でないか期限が切れた場合、認証サーバはOAuth 2.0 [RFC6749]で定義されているようにエラー応答を構築する。 "error"パラメータの値は "invalid_grant"エラーコードでなければならない（MUST）。 承認サーバーは、 "error_description"または "error_uri"パラメータを使用して、アサーションが無効とみなされた理由に関する追加情報を含めることができる（MAY）。

  例えば：

```
     HTTP/1.1 400 Bad Request
     Content-Type: application/json
     Cache-Control: no-store

     {
       "error":"invalid_grant",
       "error_description":"Audience validation failed"
     }
```

#### 4.2. Using Assertions for Client Authentication

  次のセクションでは、OAuth 2.0 [RFC6749]のセクション2.3の拡張として、クライアントクレデンシャルとしてのアサーションの使用を定義する。アサーションをクライアントの資格情報として使用する場合、クライアントはアサーションと関連情報を次のHTTPリクエストパラメータを使用して含みます。

  - `client_assertion_type`
    - 必須。許可サーバーによって定義されたアサーションの形式。値は絶対URIになります。

  - `client_assertion`
    - 必須。アサーションは、クライアントの認証に使用されます。アサーションの特定のシリアライゼーションは、プロファイル文書によって定義されます。

  - `client_id`
    - オプション。 OAuth 2.0 [RFC6749]のセクション2.2で説明されているクライアント識別子。クライアントがアサーションの主体によって識別されるため、クライアントアサーション認証には`client_id`は不要です。存在する場合、 `client_id`パラメータの値は、クライアントアサーションによって識別されるのと同じクライアントを識別しなければならない（MUST）。

  次の例は、OAuth 2.0 [RFC6749]のセクション4.1.3で定義されているように、アクセストークン要求中にアサーションを使用して認証するクライアントを示しています（表示のために余分な改行があります）。

```
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=authorization_code&
     code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&
     client_assertion_type=urn%3Aietf%3Aparams%3Aoauth
     %3Aclient-assertion-type%3Asaml2-bearer&
     client_assertion=PHNhbW...[omitted for brevity]...ZT
```

  トークンエンドポイントは、クライアント認証にアサーションを使用する場合にのみ存在する`client_assertion`および`client_assertion_type`パラメータの存在を調べることによって、アサーションベースのクレデンシャルと他のクライアントのクレデンシャルタイプを区別できます。

  `client_assertion_type`値として使用するためのIETF URNは、[RFC6755]のテンプレートを使って要求されるかもしれません。 `urn：ietf：params：oauth：client-assertion-type：*`という形式のURNが提案されています。

##### 4.2.1.  Error Responses

  アサーションが何らかの理由で無効である場合、または複数のクライアント認証メカニズムが使用されている場合、認証サーバはOAuth 2.0 [RFC6749]で定義されているエラー応答を構成します。 `error`パラメータの値は `invalid_client`エラーコードでなければならない（MUST）。 承認サーバーは、 `error_description`または `error_uri`パラメータを使用して、クライアントのアサーションが無効であると考えられた理由に関する追加情報を含めることができる（MAY）。

  例えば：

```
     HTTP/1.1 400 Bad Request
     Content-Type: application/json
     Cache-Control: no-store

     {
       "error":"invalid_client"
       "error_description":"assertion has expired"
     }
```

### 5. Assertion Content and Processing

  [RFC](https://tools.ietf.org/html/rfc7521#section-5)

  このセクションはOAuth2.0 [RFC6749]でのアサーションの使用のための一般的な内容と処理モデルを提供します。

#### 5.1. Assertion Metamodel

  以下は、OAuth 2.0でのアサーションの発行、交換、および処理に関連するエンティティおよびメタデータです。これらは一般的な用語であり、特定のアサーション形式の抽象です。これらの用語の特定の表現へのマッピングは、この仕様のプロファイルによって提供されます。

  - Issuer
    - アサーションを発行したエンティティの一意の識別子。一般に、これは、アサーションの署名または完全性保護に使用されるキーマテリアルを保持するエンティティです。発行者の例には、OAuthクライアント（アサーションが自己発行される場合）とサードパーティのセキュリティトークンサービスがあります。アサーションが自己発行されている場合、発行者の値はクライアント識別子です。アサーションがセキュリティトークンサービス（STS）によって発行された場合、発行者は承認サーバーによって認識される方法でSTSを識別する必要があります。アプリケーションプロファイルがない場合、準拠しているアプリケーションは、RFC 3986 [RFC3986]のセクション6.2.1で定義されている単純な文字列比較メソッドを使用して発行者の値を比較しなければならない（MUST）。

  - Subject
    - アサーションの対象となるプリンシパルの一意の識別子。
      - クライアント認証にアサーションを使用する場合、サブジェクトは、OAuthクライアントの「client_id」の値を使用して、クライアントを認可サーバーに識別します。
      - アサーションを認可許可として使用する場合、サブジェクトは、アクセストークンが要求されている認可されたアクセサー（通常、リソース所有者または許可された代理人）を識別します。

  - Audience
    - アサーションを処理するパーティを識別する値。 OAuth 2.0 [RFC6749]のセクション3.2で定義されているトークンエンドポイントのURLは、認証サーバーがアサーションの有効な意図されたオーディエンスであることを示すために使用できます。そうでない場合に指定するアプリケーションプロファイルがない場合、準拠するアプリケーションは、RFC 3986 [RFC3986]のセクション6.2.1で定義されている単純な文字列比較メソッドを使用してオーディエンス値を比較しなければならない（MUST）。

  - Issued At
    - アサーションが発行された時刻。シリアライゼーションはアサーション形式によって異なる場合がありますが、タイムゾーンコンポーネントを持たないUTCで時間を表現する必要があります。

  - Expires At
    - アサーションが期限切れになる時刻。シリアライゼーションはアサーション形式によって異なる場合がありますが、タイムゾーンコンポーネントを持たないUTCで時間を表現する必要があります。

  - Assertion ID
    - アサーションの一意または一意の識別子。アサーションID

#### 5.2. General Assertion Format and Processing Rules

  以下は、OAuthでのアサーションの使用に関する一般的なフォーマットと処理ルールです。

  - アサーションにはIssuerが含まれていなければならない。Issuerは、承認サーバーによって認識されたアサーションを発行したエンティティを識別します。アサーションが自己発行された場合、発行者はクライアントの`client_id`の値でなければならない。

  - アサーションはSubjectを含まなければならない（MUST）。主題は、通常、アクセストークンが要求されている許可されたアクセサー（すなわち、リソース所有者または許可された代理人）を識別するが、場合によっては、匿名の識別子または匿名のユーザーを示す他の値である可能性がある。クライアントが自身のために行動しているとき、Subjectはクライアントの`client_id`の値でなければならない（MUST）。

  - アサーションには、オーサリングサーバが意図されたオーディエンスとして識別されるAudienceが含まれていなければならない。認可サーバーは、意図したオーディエンスとして独自のIDを含まないアサーションを拒否しなければならない（MUST）。

  - アサーションには、アサーションを使用できる期間を制限するExpires Atエンティティが含まれなくてはなりません（MUST）。認可サーバは期限切れのアサーションを拒否しなければならない（MUST）。認可サーバーは、将来不合理に遠いExpires At属性値を持つアサーションを拒否することがあります。

  - アサーションは、アサーションが発行されたUTC時刻を含むIssued Atエンティティを含むことができる（MAY）。

  - 認可サーバは、無効な署名またはMACを持つアサーションを拒否しなければならない（MUST）。署名またはメッセージ認証コードを検証するために使用されるアルゴリズム、およびアサーションに対して署名またはメッセージ認証コードを生成するために使用される秘密を指定するメカニズムは、この仕様の範囲を超えています。

### 6. Common Scenarios

  [RFC](https://tools.ietf.org/html/rfc7521#section-6)

  以下では、セクション4と5で定義されているフォーマットと処理のルールを超えて、多くの一般的な使用例に対するアサーションの使用に関する追加のガイダンスを提供します。

#### 6.1. Client Authentication

  クライアントは、セクション4.2で定義された `client_assertion_type`および `client_assertion`パラメータを使用して、アサーションを使用して承認サーバのトークンエンドポイントを認証します。アサーションのSubjectがクライアントを識別します。アサーションがクライアントによって自己発行される場合、アサーションの発行者はクライアントも識別する。

  セクション4.2の例は、アクセストークン要求中にアサーションを使用して認証するクライアントを示しています。

#### 6.2. Client Acting on Behalf of Itself

  クライアントがそれ自体に代わってリソースにアクセスしているときは、OAuth 2.0 [RFC6749]のセクション4.4で定義されたクライアント資格認可と同様の方法でそれを行います。これは、認証と認可の許可使用パターンの両方を組み合わせた特殊なケースです。この場合、許可サーバーとの対話は、セクション4.2に従ってクライアント認証のアサーションを使用するものとして扱われ、クライアントは`client_credentials`という値を持つ`grant_type`パラメータを使用して、クライアントがアクセストークンのみを要求していることを示しますクライアントの資格情報

  次の例は、OAuth 2.0 [RFC6749]のセクション4.4.2で定義されているように、クライアント資格情報アクセストークン要求に使用されるアサーションを示しています（表示のために余分な改行があります）。

```
     POST /token HTTP/1.1
     Host: server.example.com
     Content-Type: application/x-www-form-urlencoded

     grant_type=client_credentials&
     client_assertion_type=urn%3Aietf%3Aparams%3Aoauth
     %3Aclient-assertion-type%3Asaml2-bearer&
     client_assertion=PHNhbW...[omitted for brevity]...ZT
```

#### 6.3. Client Acting on Behalf of a User

  クライアントがユーザに代わってリソースにアクセスしているときは、4.1節で定義した `grant_type`と`assertion`パラメータを使用します。 サブジェクトは、アクセストークンが要求されている承認されたアクセサー（通常、リソース所有者または許可された代理人）を識別します。

  セクション4.1の例は、アサーションを認可許可として使用してアクセストークン要求を行うクライアントを示しています。

##### 6.3.1. Client Acting on Behalf of an Anonymous User

  クライアントが匿名ユーザーに代わってリソースにアクセスしている場合、匿名性を示す相互に合意されたサブジェクト識別子が使用されます。 サブジェクト値は、ユーザに対する不透明な持続的または一時的な匿名識別子であってもよいし、匿名ユーザを示す合意された静的値（例えば、`anonymous`）であってもよい。 認可は、アサーションで提供される追加の属性やクレームなどの追加の基準に基づいている場合があります。 例えば、クライアントは、ベアラが含まれているクレームを通じて18歳以上であることを主張する信頼できる発行者からのアサーションを提示することができる。 この場合、ユーザーのIDに関する追加情報は含まれていませんが、アクセストークンを発行するために必要なすべてのデータが存在します。

  匿名性、偽名性、プライバシーに関する一般的な考慮事項については、[RFC6973]を参照してください。

### 7. Interoperability Considerations

  [RFC](https://tools.ietf.org/html/rfc7521#section-7)

  この仕様では、OAuth 2.0でアサーションを使用するためのフレームワークを定義しています。しかし、多くの値を表現するために使用されるデータ形式が定義されていない抽象的なフレームワークとして、この仕様では相互運用可能な実装を作成するには十分ではありません。

  特定のアサーションのためにこのフレームワークをプロファイルする他の2つの仕様が開発されました。[RFC7522]はSAML 2.0アサーションを使用し、[RFC7523]はJSON Webトークン（JWT）を使用します。このフレームワークのこれらの2つのインスタンス化は、OAuth 2.0でこれらの種類のアサーションを使用するためのアサーションエンコードおよび処理ルールに関する追加の詳細を指定します。

  ただし、特定のアサーションタイプのプロファイリングを行っても、相互運用可能な展開を実現するためには、識別子、キー、エンドポイントに関するシステムエンティティ間の合意が必要です。合意を必要とする特定の項目は、発行者IDとオーディエンスIDの値、サポートされているアサーションとクライアントの認証タイプ、トークンエンドポイントの場所、アサーションでのデジタル署名またはMACの適用と検証に使用されるキーアサーションの使用制限、許可されるアサーションの最大有効期間、アサーションの特定のサブジェクトとアトリビュートの要件そのような情報の交換は、この仕様書の範囲外であることは明らかです。特定のトラストフレームワーク、信頼のサークル、またはその他のユースケースの配備は、この仕様で定義されているいくつかの抽象フィールドで使用される値の種類について参加者間で合意する必要があります。場合によっては、これらの値を制約または処方するか、またはそれらの値を交換する方法を指定する追加のプロファイルが作成されることがあります。 「OAuth 2.0 Dynamic Client Registration Core Protocol」[OAUTH-DYN-REG]は、OAuthクライアントが認証サーバでメタデータを登録できるようにするプロファイルの1つです。

### 8. Security Considerations

  [RFC](https://tools.ietf.org/html/rfc7521#section-8)

  このセクションでは、このドキュメントで説明されているようにOAuth 2.0でアサーションを使用する場合に適用されるセキュリティ上の考慮事項について説明します。 セクション3で説明したように、アサーションを取得するには2つの方法があります。自己発行として、または第三者トークンサービスから取得します。 アサーションを取得するための実際のやりとりはこのドキュメントの範囲外ですが、詳細はセキュリティの観点から重要です。 3章では、高度なアーキテクチャの側面について説明します。 このセクションで説明するセキュリティの考慮事項の多くは、OAuth交換とクライアントがアサーションを取得する場合の両方に適用されます。

  このセクションの残りの部分では、クライアント認証と認可付与のためのアサーションを提示することに関係する交換に焦点を当てています。

#### 8.1. Forged Assertion

  - 脅威：
    - 敵対者は、（認可付与の場合）アクセストークンを取得したり、（クライアント認証メカニズムの場合に）クライアントを偽装するために、アサーションを偽造または変更する可能性があります。

  - 対策：
    - この種の攻撃を避けるために、エンティティは、アサーションの完全性を保護するための適切なメカニズムが採用されていることを保証する必要があります。 これには、アサーションにデジタル署名する発行者またはアサーションを通じてMACを計算する発行者が含まれます。

#### 8.2. Stolen Assertion

  - 脅威：
    - 敵対者は、（例えば、盗聴によって）アサーションを取得し、その後の時点でそれを再利用（リプレイ）することができる。

  - 対策：
    - この脅威の主な軽減策は、すべてのネットワーク交換に対してサーバー認証を使用する安全な通信チャネルを使用することです。

    - アサーションには、リプレイ攻撃を防ぐための要素もいくつか含まれています。 しかし、複数の交換のためのアサーションを再利用することと、新しい、新しいアサーションを取得して作成することとの間に明確なトレードオフがあります。

    - 認可サーバおよびリソースサーバは、再生保護のために、アサーションIDおよび発行済み/期限切れ属性の組み合わせを使用することができる。 以前に処理されたアサーションは、アサーションIDに基づいて拒否される可能性があります。 有効性ウィンドウの追加により、許可サーバは、処理されたアサーションIDの無限状態テーブルを維持することを免除する。

#### 8.3. Unauthorized Disclosure of Personal Information

  - 脅威：
    - 他のエンティティが認証情報、組織内の役割、またはその他の認可関連情報など、個人に関する情報を取得する能力は、プライバシーに関する懸念を提起します。

  - 対策：
    - この脅威に対処するには、2つのケースを区別する必要があります。

    - 第1に、交換に参加しなかった第三者は、TLSを使用する交換機の機密保護を採用することによって、アサーションの内容を盗聴することが防止される。これにより、ワイヤ上の盗聴者が情報を得ることができなくなります。しかしながら、これは正当なプロトコルエンティティがアサーションから持ってはいけない情報を得ることを妨げるものではない。一部のアサーションフォーマットでは、アサーションを暗号化することができ、不正な当事者がコンテンツを検査するのを防ぐことができます。

    - 第2に、認可サーバは、第三者トークンサービスによって作成されたアサーションを取得し、そのトークンサービスはアサーションに属性を配置している可能性がある。潜在的なプライバシーの問題を軽減するためには、リソース所有者からのそのような属性情報の解放のための事前の同意が得られるべきである。 OAuth自体は直接そのような機能を提供していませんが、この同意の承認は他のアイデンティティ管理プロトコルやユーザの同意を得て行うことができます。帯域外の方法で取得することもできます。

    - サードパーティのトークンサービスがクライアント認証に使用するアサーションを作成する場合、プライバシーの懸念は一般に低くなります。これらのクライアントの多くは、人間が操作する個々のデバイスではなくWebサーバーです。アサーションが、エンドユーザに密接に関連することができるデバイスまたはソフトウェアのクライアント認証に使用される場合、プライバシー保護の保護を考慮する必要があります。

    - プライバシーに配慮したプロトコル設計に関するさらなるガイダンスは、[RFC6973]にあります。

#### 8.4. Privacy Considerations

  アサーションにはプライバシーに敏感な情報が含まれている可能性があり、そのような情報が意図しない者に漏洩するのを防ぐため、TLSなどの暗号化されたチャネルを介してのみ送信する必要があります。 クライアントへの特定の情報の開示を防止することが望ましい場合は、アサーション（またはその一部）を許可サーバーに暗号化する必要があります。

  配置は、交換を完了するために必要な情報の最小量を決定し、その情報のみをアサーションに含める必要があります。 場合によっては、Subjectの識別子は、6.3.1項で説明したように、匿名または匿名のユーザーを表す値にすることができます。
